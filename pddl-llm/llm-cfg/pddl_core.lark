// ---------- PDDL core grammar (Lark) ----------
// Set start rule at runtime to either `domain` or `problem`.
// Example: CFG("start: domain\n"  + open('pddl_core.lark').read())

pddl_doc: domain | problem

// ===================== DOMAINS =====================
domain: "(" "define" domain_name require_def? types_def? constants_def? predicates_def? functions_def? constraints? structure_def* ")"
domain_name: "(" "domain" NAME ")"

require_def: "(" ":" "requirements" REQUIRE_KEY+ ")"
REQUIRE_KEY: ":" NAME

types_def: "(" ":" "types" typed_name_list ")"

// If have any typed names, they must come FIRST!
typed_name_list: ( NAME* | single_type_name_list+ NAME* )
single_type_name_list: NAME+ "-" type

type: "(" "either" prim_type+ ")" | prim_type
prim_type: NAME

functions_def: "(" ":" "functions" function_list ")"
function_list: ( atomic_function_skeleton+ ( "-" function_type )? )*

atomic_function_skeleton: "(" function_symbol typed_variable_list ")"
function_symbol: NAME
function_type: STR_NUMBER

constants_def: "(" ":" "constants" typed_name_list ")"

predicates_def: "(" ":" "predicates" atomic_formula_skeleton+ ")"
atomic_formula_skeleton: "(" predicate typed_variable_list ")"
predicate: NAME

// If have any typed variables, they must come FIRST!
typed_variable_list: ( VARIABLE* | single_type_var_list+ VARIABLE* )
single_type_var_list: VARIABLE+ "-" type

constraints: "(" ":" "constraints" con_gd ")"

structure_def: action_def | durative_action_def | derived_def

// ===================== ACTIONS =====================
action_def: "(" ":" "action" action_symbol ":" "parameters" "(" typed_variable_list ")" action_def_body ")"
action_symbol: NAME

action_def_body: ( ":" "precondition" ( "()" | goal_desc ) )? ( ":" "effect" ( "()" | effect ) )?

goal_desc: atomic_term_formula
         | "(" "and" goal_desc* ")"
         | "(" "or" goal_desc* ")"
         | "(" "not" goal_desc ")"
         | "(" "imply" goal_desc goal_desc ")"
         | "(" "exists" "(" typed_variable_list ")" goal_desc ")"
         | "(" "forall" "(" typed_variable_list ")" goal_desc ")"
         | f_comp
         | "(" "=" term term ")"

f_comp: "(" binary_comp f_exp f_exp ")"

atomic_term_formula: "(" predicate term* ")"
term: NAME | VARIABLE

// ===================== DURATIVE ACTIONS =====================
durative_action_def: "(" ":" "durative-action" action_symbol ":" "parameters" "(" typed_variable_list ")" da_def_body ")"

da_def_body: ":" "duration" duration_constraint
           | ":" "condition" ( "()" | da_gd )
           | ":" "effect"   ( "()" | da_effect )

da_gd: pref_timed_gd
     | "(" "and" da_gd* ")"
     | "(" "forall" "(" typed_variable_list ")" da_gd ")"

pref_timed_gd: timed_gd | "(" "preference" NAME? timed_gd ")"

timed_gd: "(" time_specifier goal_desc ")" | "(" "over_all" goal_desc ")"

time_specifier: "atstart" | "atend"
interval: "over_all"

// ===================== DERIVED DEFINITIONS =====================
derived_def: "(" ":" "derived" atomic_formula_skeleton goal_desc ")"

// ===================== EXPRESSIONS =====================
f_exp: NUMBER
     | "(" binary_op f_exp f_exp ")"
     | "(" "-" f_exp ")"
     | f_head

f_head: "(" function_symbol term* ")" | function_symbol

effect: "(" "and" c_effect* ")" | c_effect

c_effect: "(" "forall" "(" typed_variable_list ")" effect ")"
        | "(" "when" goal_desc cond_effect ")"
        | p_effect

p_effect: "(" assign_op f_head f_exp ")"
        | "(" "not" atomic_term_formula ")"
        | atomic_term_formula

cond_effect: "(" "and" p_effect* ")" | p_effect

binary_op: "*" | "+" | "-" | "/"
binary_comp: ">" | "<" | "=" | ">=" | "<="

assign_op: "assign" | "scale-up" | "scale-down" | "increase" | "decrease"

// ===================== DURATIONS =====================
duration_constraint: "(" "and" simple_duration_constraint+ ")" | "()" | simple_duration_constraint
simple_duration_constraint: "(" dur_op "?" "duration" dur_value ")" | "(" time_specifier simple_duration_constraint ")"
dur_op: "<=" | ">=" | "="
dur_value: NUMBER | f_exp

da_effect: "(" "and" da_effect* ")"
        | timed_effect
        | "(" "forall" "(" typed_variable_list ")" da_effect ")"
        | "(" "when" da_gd timed_effect ")"
        | "(" assign_op f_head f_exp_da ")"


timed_effect: "(" time_specifier da_effect ")"
        | "(" time_specifier f_assign_da ")"
        | "(" assign_op f_head f_exp ")"

f_assign_da: "(" assign_op f_head f_exp_da ")"
f_exp_da: "(" ( binary_op f_exp_da f_exp_da | "-" f_exp_da ) ")"
        | "?" "duration"
        | f_exp

// ===================== PROBLEMS =====================
problem: "(" "define" problem_decl problem_domain require_def? object_decl? init goal prob_constraints? metric_spec? ")"

problem_decl: "(" "problem" NAME ")"
problem_domain: "(" ":" "domain" NAME ")"

object_decl: "(" ":" "objects" typed_name_list ")"

init: "(" ":" "init" init_el* ")"

// Note: timed initial literals allowed per original grammar
init_el: name_literal
       | "(" "=" f_head NUMBER ")"
       | "(" NUMBER name_literal ")"

name_literal: atomic_name_formula | "(" "not" atomic_name_formula ")"
atomic_name_formula: "(" predicate NAME* ")"

goal: "(" ":" "goal" goal_desc ")"

prob_constraints: "(" ":" "constraints" pref_con_gd ")"

pref_con_gd: "(" "and" pref_con_gd* ")"
           | "(" "forall" "(" typed_variable_list ")" pref_con_gd ")"
           | "(" "preference" NAME? con_gd ")"
           | con_gd

metric_spec: "(" ":" "metric" optimization metric_f_exp ")"

optimization: "minimize" | "maximize"

metric_f_exp: "(" binary_op metric_f_exp metric_f_exp ")"
            | "(" ( "*" | "/" ) metric_f_exp metric_f_exp+ ")"
            | "(" "-" metric_f_exp ")"
            | NUMBER
            | "(" function_symbol NAME* ")"
            | function_symbol
            | "total-time"
            | "(" "is-violated" NAME ")"

// PDDL3 state trajectory constraints
con_gd: "(" "and" con_gd* ")"
      | "(" "forall" "(" typed_variable_list ")" con_gd ")"
      | "(" "at_end" goal_desc ")"
      | "(" "always" goal_desc ")"
      | "(" "sometime" goal_desc ")"
      | "(" "within" NUMBER goal_desc ")"
      | "(" "at-most-once" goal_desc ")"
      | "(" "sometime-after" goal_desc goal_desc ")"
      | "(" "sometime-before" goal_desc goal_desc ")"
      | "(" "always-within" NUMBER goal_desc goal_desc ")"
      | "(" "hold-during" NUMBER NUMBER goal_desc ")"
      | "(" "hold-after" NUMBER goal_desc ")"

// ===================== LEXER / TOKENS =====================
NAME: /[A-Za-z][A-Za-z0-9_-]*/
VARIABLE: /\?[A-Za-z][A-Za-z0-9_-]*/
NUMBER: /[0-9]+(\.[0-9]+)?/
STR_NUMBER: NUMBER

COMMENT: /;[^\n\r]*/
%ignore COMMENT

%import common.WS
%ignore WS
